<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ä¸ƒå¤•å¿«ä¹ â¤ï¸</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { height: 100%; }
body {
  min-height: 100vh;
  background: url('bg.jpg') no-repeat center center / cover fixed;
  font-family: 'å¾®è½¯é›…é»‘', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, 'Noto Sans', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* é¡¶éƒ¨æ—¶é—´æ˜¾ç¤ºï¼ˆç»ç’ƒæ‹Ÿç‰©ï¼‰ */
#timeTogether {
  font-size: 4rem;
  font-weight: 800;
  color: #ffd2e1;
  text-align: center;
  margin-top: 8vh;
  padding: .5rem 1.25rem;
  border-radius: 16px;
  backdrop-filter: blur(6px) saturate(1.2);
  -webkit-backdrop-filter: blur(6px) saturate(1.2);
  background: linear-gradient(180deg, rgba(255, 128, 173, .14), rgba(255, 96, 144, .08));
  border: 1px solid rgba(255, 150, 180, .25);
  box-shadow:
    0 10px 30px rgba(255, 77, 109, .22),
    inset 0 0 20px rgba(255, 255, 255, .08);
  text-shadow: 0 6px 24px rgba(255, 77, 109, .6);
}

/* ä¸­é—´å†…å®¹å®¹å™¨ */
.middle {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  flex: 1;
  padding-top: 26vh;
}

/* æ ‡é¢˜æ‹Ÿç‰©å…‰æ™• */
#question {
  font-size: 5rem;
  font-weight: 900;
  color: #ff4d6d;
  letter-spacing: 2px;
  text-shadow:
    0 0 0 transparent,
    0 10px 30px rgba(255, 77, 109, .45),
    0 0 30px rgba(255, 180, 200, .55);
  text-align: center;
  margin-bottom: 4vh;
  padding: 0 .5rem;
}

/* æŒ‰é’®ç»„ */
#buttons { text-align: center; }

/* æ‹Ÿç‰©æŒ‰é’® */
.btn {
  padding: 18px 40px;
  font-size: 2rem;
  border: none;
  border-radius: 14px;
  cursor: pointer;
  margin: 15px;
  transition: transform .18s ease, box-shadow .18s ease, filter .18s ease;
  will-change: transform;
  user-select: none;
}

#yes {
  background: radial-gradient(120% 120% at 70% 30%, #ff99ad, #ff4d6d 55%, #e91948 100%);
  color: #fff;
  box-shadow:
    0 12px 28px rgba(233, 25, 72, .36),
    0 4px 10px rgba(233, 25, 72, .25),
    inset 0 2px 18px rgba(255,255,255,.35);
  text-shadow: 0 4px 18px rgba(255,255,255,.25);
}
#yes:hover { transform: translateY(-2px) scale(1.03); filter: brightness(1.05); }
#yes:active { transform: translateY(0) scale(.99); filter: brightness(.98); }

#no {
  background: linear-gradient(180deg, #7a7a7a, #565656);
  color: #fff;
  box-shadow:
    0 12px 24px rgba(0,0,0,.25),
    inset 0 2px 18px rgba(255,255,255,.15);
}
#no:hover { transform: translateY(-2px); filter: brightness(1.02); }
#no:active { transform: translateY(0); filter: brightness(.98); }

canvas#fireworks {
  position: fixed;
  inset: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 10;
}

/* æ‰‹æœºé€‚é… */
@media (max-width: 1024px) {
  #timeTogether { font-size: 3.2rem; margin-top: 6vh; }
  #question { font-size: 4.2rem; }
}
@media (max-width: 768px) {
  #timeTogether { font-size: 2.6rem; margin-top: 4vh; }
  #question { font-size: 3.2rem; margin-bottom: 3vh; }
  .btn { padding: 16px 28px; font-size: 1.6rem; }
}
@media (max-width: 480px) {
  #timeTogether { font-size: 2.2rem; margin-top: 3vh; }
  #question { font-size: 2.6rem; margin-bottom: 2.4vh; }
  .btn { padding: 16px 26px; font-size: 1.5rem; }
}

/* è¿åŠ¨å‡å°‘åå¥½ */
@media (prefers-reduced-motion: reduce) {
  #fireworks { display: none; }
}
</style>
</head>
<body>
<!-- éŸ³é¢‘æ–‡ä»¶æ”¾åœ¨ä¸ index.html åŒçº§ç›®å½• -->
<audio id="bgm" preload="auto" autoplay loop playsinline>
  <source src="zshyn.mp3" type="audio/mpeg" />
</audio>
<audio id="yesMusic" preload="auto" playsinline>
  <source src="yyzyq.mp3" type="audio/mpeg" />
</audio>

<h1 id="timeTogether"></h1>

<div class="middle">
  <h2 id="question">ä½ æ„¿æ„å’Œæˆ‘æ°¸è¿œåœ¨ä¸€èµ·å—ï¼Ÿ</h2>
  <div id="buttons">
    <button id="yes" class="btn">æ„¿æ„ â¤ï¸</button>
    <button id="no" class="btn">ä¸è¦ ğŸ˜¢</button>
  </div>
</div>

<canvas id="fireworks"></canvas>

<script>
/* =========================
   åœ¨ä¸€èµ·æ—¶é—´æ˜¾ç¤º
   ========================= */
const startDate = new Date("2024-06-28T00:00:00");
const timeEl = document.getElementById("timeTogether");
function updateTime() {
  const now = new Date();
  const diff = now - startDate;
  const days = Math.floor(diff / (1000 * 60 * 60 * 24));
  const hours = Math.floor((diff / (1000 * 60 * 60)) % 24);
  const minutes = Math.floor((diff / (1000 * 60)) % 60);
  const seconds = Math.floor((diff / 1000) % 60);
  timeEl.innerText = `æˆ‘ä»¬å·²ç»åœ¨ä¸€èµ· ${days} å¤© ${hours} å°æ—¶ ${minutes} åˆ† ${seconds} ç§’`;
}
setInterval(updateTime, 1000);
updateTime();

/* =========================
   æŒ‰é’®äº¤äº’ä¸éŸ³é¢‘æ§åˆ¶
   ========================= */
const yesBtn = document.getElementById("yes");
const noBtn = document.getElementById("no");
const bgm = document.getElementById("bgm");
const yesMusic = document.getElementById("yesMusic");

bgm.volume = 0.6;
yesMusic.volume = 1.0;

// é¦–æ¬¡ç”¨æˆ·äº¤äº’æ—¶å°è¯•æ’­æ”¾èƒŒæ™¯éŸ³ä¹ï¼ˆè§£å†³è‡ªåŠ¨æ’­æ”¾é™åˆ¶ï¼‰
const unlockAudio = () => {
  if (bgm.paused) bgm.play().catch(()=>{});
  document.removeEventListener('pointerdown', unlockAudio);
  document.removeEventListener('touchstart', unlockAudio);
};
document.addEventListener('pointerdown', unlockAudio, { once: true });
document.addEventListener('touchstart', unlockAudio, { once: true });

noBtn.addEventListener("click", () => {
  let yesSize = parseFloat(window.getComputedStyle(yesBtn).fontSize);
  let noSize = parseFloat(window.getComputedStyle(noBtn).fontSize);
  yesBtn.style.fontSize = (yesSize * 1.18) + "px";
  noBtn.style.fontSize = (Math.max(12, noSize * 0.82)) + "px";
});

// ç®€å•éŸ³é‡æ·¡å…¥æ·¡å‡º
function fadeVolume(audio, target, duration = 300) {
  const start = audio.volume;
  const change = target - start;
  const t0 = performance.now();
  const step = (now) => {
    const t = Math.min(1, (now - t0) / duration);
    audio.volume = Math.max(0, Math.min(1, start + change * t));
    if (t < 1) requestAnimationFrame(step);
  };
  requestAnimationFrame(step);
}

yesBtn.addEventListener("click", () => {
  // ç¡®ä¿èƒŒæ™¯éŸ³ä¹å·²è§£é”å¹¶æ’­æ”¾
  if (bgm.paused) bgm.play().catch(()=>{});
  // â€œæ„¿æ„â€çŸ­éŸ³ä¹æ’­æ”¾ï¼Œå‹ä½BGMå†æ¢å¤
  try {
    fadeVolume(bgm, 0.25, 200);
    yesMusic.currentTime = 0;
    yesMusic.play().catch(()=>{});
    yesMusic.onended = () => fadeVolume(bgm, 0.6, 400);
  } catch(e) {}

  // ä»…åœ¨ç‚¹å‡»â€œæ„¿æ„â€æ—¶è§¦å‘çƒŸèŠ±
  celebratoryHearts();
});

/* =========================
   æ‹Ÿç‰©çƒŸèŠ±å¼•æ“ï¼ˆé«˜é¢œå€¼ï¼Œæ— é»‘çƒŸï¼‰
   ========================= */
const canvas = document.getElementById("fireworks");
const ctx = canvas.getContext("2d", { alpha: true });
let DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
function resizeCanvas() {
  DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
  canvas.width = Math.floor(window.innerWidth * DPR);
  canvas.height = Math.floor(window.innerHeight * DPR);
  canvas.style.width = window.innerWidth + "px";
  canvas.style.height = window.innerHeight + "px";
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.scale(DPR, DPR);
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// å·¥å…·
const rand = (min, max) => Math.random() * (max - min) + min;
const TAU = Math.PI * 2;
function hsla(h, s, l, a) { return `hsla(${h}, ${s}%, ${l}%, ${a})`; }
function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function mix(a, b, t) { return a + (b - a) * t; }

const palettes = [
  { name: 'gold', hues: [46, 50, 54], s: [88, 100], l: [55, 70], glitter: [55, 70] },
  { name: 'rose', hues: [330, 345, 355], s: [85, 100], l: [55, 70], glitter: [65, 80] },
  { name: 'peach', hues: [12, 18, 24], s: [85, 100], l: [55, 72], glitter: [65, 78] },
  { name: 'aqua', hues: [180, 190, 200], s: [70, 95], l: [55, 72], glitter: [60, 75] },
  { name: 'violet', hues: [255, 270, 285], s: [70, 95], l: [55, 72], glitter: [60, 75] },
  { name: 'emerald', hues: [135, 145, 155], s: [70, 95], l: [50, 68], glitter: [60, 76] },
];
function pickPalette() {
  const p = palettes[Math.floor(Math.random() * palettes.length)];
  const hue = p.hues[Math.floor(Math.random() * p.hues.length)];
  const sat = Math.floor(rand(p.s[0], p.s[1]));
  const lig = Math.floor(rand(p.l[0], p.l[1]));
  return { hue, sat, lig, glitter: Math.floor(rand(p.glitter[0], p.glitter[1])) };
}

// ç‰©ç†å‚æ•°
const Physics = {
  gravity: 240,          // é‡åŠ› px/s^2
  airDrag: 0.992,        // ç©ºæ°”é˜»å°¼ï¼ˆç²’å­ï¼‰
  rocketDrag: 0.998,     // ç©ºæ°”é˜»å°¼ï¼ˆç«ç®­ï¼‰ç•¥å°ï¼Œé£æ›´é«˜
  windStrength: 4,       // å¾®é£å¼ºåº¦
};

// å®¹å™¨
const particles = [];
const rockets = [];
const shockwaves = [];

// ç²’å­
class Particle {
  constructor(opts) {
    this.x = opts.x; this.y = opts.y;
    this.vx = opts.vx; this.vy = opts.vy;
    this.size = opts.size || rand(1.2, 2.4);
    this.ttl = opts.ttl || rand(0.9, 1.9);
    this.life = 0;
    this.color = opts.color || pickPalette();
    this.alpha = 1;
    this.glitter = opts.glitter ?? Math.random() < 0.45;
    this.twinkle = Math.random() < 0.35;
    this.type = opts.type || 'spark';
    this.heavy = !!opts.heavy; // æŸ³å¼æ‹–å°¾
    this.trail = [];
    this.maxTrail = this.heavy ? 10 : 6;
    this.bokeh = Math.random() < 0.12;
  }
  update(dt, windT) {
    // è½¨è¿¹
    this.trail.push([this.x, this.y]);
    if (this.trail.length > this.maxTrail) this.trail.shift();

    // åŠ›
    const wind = Math.sin(windT + this.y * 0.002) * (this.heavy ? Physics.windStrength * 0.2 : Physics.windStrength);
    this.vx += wind * dt;
    this.vy += Physics.gravity * dt * (this.heavy ? 1.1 : 1);

    // é˜»å°¼
    this.vx *= Physics.airDrag;
    this.vy *= Physics.airDrag;

    // ç§»åŠ¨
    this.x += this.vx * dt;
    this.y += this.vy * dt;

    // ç”Ÿå‘½å‘¨æœŸ
    this.life += dt;
    this.alpha = 1 - (this.life / this.ttl);
    if (this.twinkle) {
      this.alpha *= 0.7 + Math.sin(this.life * 40 + this.x * 0.05) * 0.3;
      this.alpha = clamp(this.alpha, 0, 1);
    }
    return this.life < this.ttl && this.alpha > 0.02;
  }
  draw(ctx) {
    const { hue, sat, lig } = this.color;
    const core = hsla(hue, sat, lig + 10, clamp(this.alpha, 0, 1));
    const glow = hsla(hue, sat, 60, clamp(this.alpha * 0.3, 0, 0.6));

    // æ‹–å°¾
    if (this.trail.length > 1) {
      ctx.lineWidth = this.heavy ? 2 : 1.25;
      ctx.strokeStyle = glow;
      ctx.beginPath();
      const [sx, sy] = this.trail[0];
      ctx.moveTo(sx, sy);
      for (let i = 1; i < this.trail.length; i++) {
        const [tx, ty] = this.trail[i];
        ctx.lineTo(tx, ty);
      }
      ctx.stroke();
    }

    // ä¸»ä½“
    ctx.beginPath();
    ctx.fillStyle = core;
    ctx.shadowBlur = 18;
    ctx.shadowColor = glow;
    ctx.arc(this.x, this.y, this.bokeh ? this.size * 1.8 : this.size, 0, TAU);
    ctx.fill();
    ctx.shadowBlur = 0;

    // é—ªäº®ç¢é’»
    if (this.glitter && Math.random() < 0.6) {
      ctx.globalAlpha = clamp(this.alpha * 0.8, 0, 1);
      ctx.fillStyle = hsla(hue, 100, 90, 0.9);
      ctx.fillRect(this.x + rand(-0.7, 0.7), this.y + rand(-0.7, 0.7), 1.2, 1.2);
      ctx.globalAlpha = 1;
    }
  }
}

// å†²å‡»æ³¢
class Shockwave {
  constructor(x, y, color) {
    this.x = x; this.y = y;
    this.r = 0;
    this.ttl = rand(0.35, 0.6);
    this.life = 0;
    this.color = color;
  }
  update(dt) {
    this.life += dt;
    this.r += 200 * dt;
    return this.life < this.ttl;
  }
  draw(ctx) {
    const t = 1 - (this.life / this.ttl);
    ctx.lineWidth = mix(3.5, 0.3, 1 - t);
    ctx.strokeStyle = hsla(this.color.hue, this.color.sat, mix(72, 58, 1 - t), Math.max(0, Math.min(0.8, t * 0.8)));
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r, 0, TAU);
    ctx.stroke();
  }
}

// ç«ç®­
class Rocket {
  constructor(x, y, vx, vy, palette, forceType) {
    this.x = x; this.y = y;
    this.vx = vx; this.vy = vy;
    this.ttl = rand(1.0, 1.9);
    this.life = 0;
    this.palette = palette || pickPalette();
    this.forceType = forceType || null;
    this.trail = [];
  }
  update(dt, windT) {
    // è½¨è¿¹
    this.trail.push([this.x, this.y]);
    if (this.trail.length > 14) this.trail.shift();

    // é£ä¸é‡åŠ›
    const wind = Math.sin(windT + this.y * 0.0015) * (Physics.windStrength * 0.5);
    this.vx += wind * dt;
    this.vy += Physics.gravity * 0.85 * dt;

    // é˜»å°¼
    this.vx *= Physics.rocketDrag;
    this.vy *= Physics.rocketDrag;

    // ç§»åŠ¨
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    this.life += dt;

    // çˆ†ç‚¸æ¡ä»¶ï¼šå°½é‡å‡åˆ°å±å¹•é¡¶éƒ¨ 10% åŒºåŸŸ
    const explodeTop = this.y < innerHeight * 0.10;
    const explodeApex = this.vy > 20; // å¼€å§‹æ˜æ˜¾ä¸‹è½
    const explodeTimeout = this.life > this.ttl + 0.3;
    const explode = explodeTop || explodeApex || explodeTimeout;
    return !explode;
  }
  draw(ctx) {
    // å½—æ˜Ÿå¤´
    const head = hsla(this.palette.hue, this.palette.sat, 70, 1);
    const glow = hsla(this.palette.hue, this.palette.sat, 60, 0.5);
    ctx.globalCompositeOperation = 'lighter';
    ctx.beginPath();
    ctx.shadowBlur = 24;
    ctx.shadowColor = glow;
    ctx.fillStyle = head;
    ctx.arc(this.x, this.y, 2.4, 0, TAU);
    ctx.fill();
    ctx.shadowBlur = 0;

    // å½—å°¾
    if (this.trail.length > 1) {
      ctx.lineWidth = 2.2;
      const grad = ctx.createLinearGradient(this.trail[0][0], this.trail[0][1], this.x, this.y);
      grad.addColorStop(0, hsla(this.palette.hue, this.palette.sat, 60, 0));
      grad.addColorStop(1, hsla(this.palette.hue, this.palette.sat, 70, 0.9));
      ctx.strokeStyle = grad;
      ctx.beginPath();
      ctx.moveTo(this.trail[0][0], this.trail[0][1]);
      for (let i = 1; i < this.trail.length; i++) {
        ctx.lineTo(this.trail[i][0], this.trail[i][1]);
      }
      ctx.stroke();
    }
  }
}

// çˆ†ç‚¸å›¾æ¡ˆ
function explodePattern(type, cx, cy, palette) {
  const speed = rand(180, 340);
  const count = Math.floor(rand(140, 240));
  const heavyChance = type === 'willow' ? 0.7 : 0.25;

  const pushParticle = (vx, vy, heavy=false) => {
    particles.push(new Particle({
      x: cx, y: cy,
      vx, vy,
      size: heavy ? rand(1.6, 2.8) : rand(1.2, 2.0),
      ttl: heavy ? rand(1.6, 2.6) : rand(1.1, 1.9),
      color: palette,
      heavy
    }));
  };

  switch(type) {
    case 'ring': {
      const rings = Math.random() < 0.5 ? 1 : 2;
      for (let r = 0; r < rings; r++) {
        const radiusScale = r === 0 ? 1 : 0.62;
        for (let i = 0; i < count; i++) {
          const a = (i / count) * TAU;
          pushParticle(Math.cos(a) * speed * radiusScale, Math.sin(a) * speed * radiusScale, Math.random() < heavyChance);
        }
      }
      break;
    }
    case 'heart': {
      // å¿ƒå½¢å‚æ•°æ–¹ç¨‹
      const n = Math.max(200, count);
      const s = rand(8, 12);
      for (let i = 0; i < n; i++) {
        const t = (i / n) * TAU;
        const x = 16 * Math.pow(Math.sin(t), 3);
        const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        const nx = x * s, ny = -y * s;
        const len = Math.hypot(nx, ny) || 1;
        pushParticle((nx/len) * speed, (ny/len) * speed, Math.random() < 0.2);
      }
      break;
    }
    case 'willow': {
      const n = count * 1.1;
      for (let i = 0; i < n; i++) {
        const a = Math.random() * TAU;
        const k = Math.pow(Math.random(), 0.25);
        pushParticle(Math.cos(a) * speed * k * 0.85, Math.sin(a) * speed * k * 0.6 - rand(30, 60), true);
      }
      break;
    }
    case 'chrysanthemum': {
      const petals = Math.floor(rand(6, 11));
      for (let i = 0; i < count; i++) {
        const a = Math.random() * TAU;
        const r = (Math.sin(petals * a) + 1) * 0.5;
        pushParticle(Math.cos(a) * speed * (0.6 + 0.5 * r), Math.sin(a) * speed * (0.6 + 0.5 * r), Math.random() < heavyChance);
      }
      break;
    }
    default: { // peony
      for (let i = 0; i < count; i++) {
        const a = Math.random() * TAU;
        const k = Math.pow(Math.random(), 0.8);
        pushParticle(Math.cos(a) * speed * k, Math.sin(a) * speed * k, Math.random() < heavyChance);
      }
    }
  }

  // å†²å‡»æ³¢ä¸æ ¸å¿ƒå…‰æ™•
  shockwaves.push(new Shockwave(cx, cy, palette));
  // ä¸­å¿ƒå¼ºå…‰
  for (let i = 0; i < 20; i++) {
    particles.push(new Particle({
      x: cx, y: cy,
      vx: rand(-40, 40), vy: rand(-40, 40),
      size: rand(1.4, 2.2),
      ttl: rand(0.5, 1.0),
      color: palette,
      heavy: false,
      glitter: true
    }));
  }
}

function explodeAt(x, y, palette, forceType) {
  const r = Math.random();
  const type = forceType || (r < 0.18 ? 'ring' : r < 0.38 ? 'chrysanthemum' : r < 0.65 ? 'peony' : r < 0.88 ? 'willow' : 'heart');
  explodePattern(type, x, y, palette || pickPalette());
}

function launchRocket(x, strength=1, palette, forceType) {
  const baseX = x ?? rand(innerWidth * 0.15, innerWidth * 0.85);
  const speed = rand(420, 580) * strength; // æå‡åˆé€Ÿåº¦ï¼Œå‡å¾—æ›´é«˜
  const angle = rand(-Math.PI * 0.06, Math.PI * 0.06);
  const vx = Math.sin(angle) * (speed * 0.20);
  const vy = -Math.cos(angle) * speed;
  rockets.push(new Rocket(baseX, innerHeight + 10, vx, vy, palette || pickPalette(), forceType));
}

/* ä»…åœ¨ç‚¹å‡»â€œæ„¿æ„â€åè§¦å‘çš„ç¤¼èŠ±é˜µåˆ—ï¼ˆé¡¶ç«¯çˆ±å¿ƒä¸ºä¸»ï¼‰ */
function celebratoryHearts() {
  const cols = 5;
  const paletteHeart = { hue: 345, sat: 95, lig: 62, glitter: 78 }; // ç”œèœœç«çº¢
  const spacing = innerWidth / (cols + 1);
  let delay = 0;

  // å¤šåˆ—çˆ±å¿ƒç«ç®­ï¼ˆæ›´å¼ºæ¨åŠ›ï¼‰
  for (let i = 1; i <= cols; i++) {
    setTimeout(() => {
      const x = spacing * i;
      launchRocket(x, 1.25, paletteHeart, 'heart');
    }, delay);
    delay += 160;
  }

  // è¿½åŠ ç‚¹ç¼€ï¼ˆé‡‘è‰²èŠèŠ±/ç‰¡ä¸¹ï¼Œå‡é«˜ï¼‰
  const extras = 6;
  for (let i = 0; i < extras; i++) {
    setTimeout(() => {
      const pal = Math.random() < 0.5 ? { hue: 50, sat: 95, lig: 62, glitter: 70 } : pickPalette();
      launchRocket(rand(innerWidth * 0.2, innerWidth * 0.8), rand(1.15, 1.35), pal, Math.random() < 0.5 ? 'chrysanthemum' : 'peony');
    }, delay + i * 140);
  }
}

// åŠ¨ç”»å¾ªç¯ï¼ˆæ— è‡ªåŠ¨çƒŸèŠ±ï¼‰
let windT = 0;
let last = performance.now();
function frame(now) {
  const dt = Math.min(0.033, (now - last) / 1000); // seconds
  last = now;
  windT += dt * 0.8;

  // æ¸éšå°¾è¿¹ï¼ˆä¸é®æŒ¡é¡µé¢èƒŒæ™¯ï¼‰
  ctx.globalCompositeOperation = 'destination-out';
  ctx.fillStyle = 'rgba(0, 0, 0, 0.16)';
  ctx.fillRect(0, 0, innerWidth, innerHeight);

  // äº®åº¦å åŠ 
  ctx.globalCompositeOperation = 'lighter';

  // æ›´æ–°ç«ç®­
  for (let i = rockets.length - 1; i >= 0; i--) {
    const r = rockets[i];
    const alive = r.update(dt, windT);
    r.draw(ctx);
    if (!alive) {
      explodeAt(r.x, r.y, r.palette, r.forceType);
      rockets.splice(i, 1);
    }
  }

  // æ›´æ–°ç²’å­
  const targetMax = innerWidth < 600 ? 900 : 1400;
  if (particles.length > targetMax) particles.splice(0, particles.length - targetMax);

  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    if (!p.update(dt, windT)) {
      particles.splice(i, 1);
      continue;
    }
    p.draw(ctx);
    // å¶å‘å°äº®ç‰‡
    if (Math.random() < 0.05 && p.alpha > 0.6) {
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      ctx.fillRect(p.x + rand(-1, 1), p.y + rand(-1, 1), 1, 1);
    }
  }

  // å†²å‡»æ³¢ï¼ˆæœ€åç»˜åˆ¶ï¼‰
  for (let i = shockwaves.length - 1; i >= 0; i--) {
    const s = shockwaves[i];
    if (!s.update(dt)) shockwaves.splice(i, 1);
    else s.draw(ctx);
  }

  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

// ä¸è‡ªåŠ¨è§¦å‘çƒŸèŠ±ï¼Œä¹Ÿä¸å“åº”é¡µé¢ç‚¹å‡»ï¼Œåªåœ¨â€œæ„¿æ„â€åè§¦å‘ã€‚
</script>
</body>
</html>
